trait AssignRound<Rhs = Self>
    type Round;
    type Ordering;
    assign_round(&mut self, Rhs, Round) -> Ordering;

trait FromRound<Val, Prec>
    type Round;
    type Ordering
    from_round(Val, Prec, Round) -> (Self, Ordering);

trait AddRound<Rhs = Self>
    type Round;
    type Ordering;
    type Output;
    add_round(self, Rhs, Round) -> (Output, Ordering);

trait SubRound<Rhs = Self>
    type Round;
    type Ordering;
    type Output;
    sub_round(self, Rhs, Round) -> (Output, Ordering);

trait MulRound<Rhs = Self>
    type Round;
    type Ordering;
    type Output;
    mul_round(self, Rhs, Round) -> (Output, Ordering);

trait DivRound<Rhs = Self>
    type Round;
    type Ordering;
    type Output;
    div_round(self, Rhs, Round) -> (Output, Ordering);

trait ShlRound<Rhs>
    type Round;
    type Ordering;
    type Output;
    shl_round(self, Rhs, Round) -> (Output, Ordering);

trait ShrRound<Rhs>
    type Round;
    type Ordering;
    type Output;
    shr_round(self, Rhs, Round) -> (Output, Ordering);

trait PowRound<Rhs>
    type Round;
    type Ordering;
    type Output;
    pow_round(self, Rhs, Round) -> (Output, Ordering);




exp_min() -> i32;
exp_max() -> i32;
prec_min() -> u32;
prec_max() -> u32;

enum Round: Nearest, Zero, Up, Down, AwayFromZero
enum Constant: Log2, Pi, Euler, Catalan
enum Special: Zero, MinusZero, Infinity, MinusInfinity, Nan

struct Float;
impl Drop for Float;
impl Clone for Float;

math_op1!
    method(&mut self, T...) -> &mut Float;
    method_set(&mut self, &Float, T...) -> &mut Float;
    method_round(&mut self, T..., Round) -> Ordering;
    method_set_round(&mut self, &Float, T..., Round) -> Ordering;

math_op2!
    method(&mut self, &Float) -> &mut Float;
    method_set(&mut self, &Float, &Float) -> &mut Float;
    method_round(&mut self, &Float, Round) -> Ordering;
    method_set_round(&mut self, &Float, &Float, Round) -> Ordering;

impl Float
    new(u32) -> Float;
    prec(&self) -> u32;
    set_prec(&mut self, u32);
    set_prec_round(&mut self, u32, Round) -> Ordering;
    to_integer(&self) -> Option<Integer>;
    to_integer_round(&self, Round) -> Option<(Integer, Ordering)>;
    to_integer_exp(&self) -> Option<(Integer, i32)>;
    to_rational(&self) -> Option<Rational>;
    to_u32_saturating(&self) -> Option<u32>;
    to_u32_saturating_round(&self, Round) -> Option<u32>;
    to_i32_saturating(&self) -> Option<i32>;
    to_i32_saturating_round(&self, Round) -> Option<i32>;
    to_f64(&self) -> f64;
    to_f64_round(&self, Round) -> f64;
    to_f32(&self) -> f32;
    to_f32_round(&self, Round) -> f32;
    math_op1! square, sqrt;
    set_sqrt_u(&mut self, u32) -> &mut Float;
    set_sqrt_u_round(&mut self, u32, Round) -> Ordering;
    math_op1! recip_sqrt, cbrt, root;
    abs(&mut self) -> &mut Float;
    set_abs(&mut self, &Float) -> &mut Float;
    set_abs_round(&mut self, &Float, Round) -> Ordering;
    recip(&mut self) -> &mut Float;
    set_recip(&mut self, &Float) -> &mut Float;
    recip_round(&mut self, Round) -> Ordering;
    set_recip_round(&mut self, &Float, Round) -> Ordering;
    math_op2! dim;
    cmp_abs(&self, &Float) -> Option<Ordering>;
    math_op1! ln, log2, log10, exp, exp2, exp10, cos, sin, tan;
    sin_cos(&mut self, &Float);
    set_sin_cos(&mut self, &mut Float, &Float);
    sin_cos_round(&mut self, &Float, Round) -> (Ordering, Ordering);
    set_sin_cos_round(&mut self, &mut Float, &Float, Round) -> (Ordering, Ordering);
    math_op1! sec, csc, cot, acos, asin, atan;
    math_op2! atan2;
    math_op1! cosh, sinh, tanh;
    sinh_cosh(&mut self, &Float);
    set_sinh_cosh(&mut self, &mut Float, &Float);
    sinh_cosh_round(&mut self, &Float, Round) -> (Ordering, Ordering);
    set_sinh_cosh_round(&mut self, &mut Float, &Float, Round) -> (Ordering, Ordering);
    math_op1! sech, csch, coth, acosh, asinh, atanh;
    set_factorial_u(&mut self, u32) -> &mut Float;
    set_factorial_u_round(&mut self, u32, Round) -> Ordering;
    math_op1! ln_1p, exp_m1, eint, li2, gamma, ln_gamma;
    lgamma(&mut self) -> Ordering;
    set_lgamma(&mut self, &Float) -> Ordering;
    lgamma_round(&mut self, Round) -> (Ordering, Ordering);
    set_lgamma_round(&mut self, &Float, Round) -> (Ordering, Ordering);
    math_op1! digamma, zeta;
    set_zeta_u(&mut self, u32) -> &mut Float;
    set_zeta_u_round(&mut self, u32, Round) -> Ordering;
    math_op1! erf, erfc, j0, j1, jn, y0, y1, yn;
    math_op2! agm, hypot;
    math_op1! ai, ceil, floor, round, trunc;
    is_integer(&self) -> bool;
    is_nan(&self) -> bool;
    is_infinite(&self) -> bool;
    is_finite(&self) -> bool;
    is_zero(&self) -> bool;
    is_normal(&self) -> bool;
    sign(&self) -> Option<Ordering>;
    get_exp(&self) -> Option<i32>;
    get_sign(&self) -> bool;
    subnormalize(&mut self) -> &mut Float;
    subnormalize_round(&mut self, Round) -> Ordering;
    assign_random_bits(&mut self, &mut R: Rng);
    assign_random_bits_round(&mut self, &mut R: Rng, Round) -> Ordering;
    assign_random_cont(&mut self, &mut R: Rng);
    assign_random_cont_round(&mut self, &mut R: Rng, Round) -> Ordering;
    to_string_radix(&self, i32, Option<usize>) -> String;
    to_string_radix_round(&self, i32, Option<usize>, Round) -> String;
    from_str(&str, u32) -> Result<Float, ParseFloatError>;
    from_str_radix(&str, i32, u32) -> Result<Float, ParseFloatError>;
    from_str_round(&str, u32, Round) -> Result<(Float, Ordering), ParseFloatError>;
    from_str_radix_round(&str, i32, u32, Round) -> Result<(Float, Ordering), ParseFloatError>;
    assign_str(&mut self, &str) -> Result<(), ParseFloatError>;
    assign_str_radix(&mut self, &str, i32) -> Result<(), ParseFloatError>;
    assign_str_round(&mut self, &str, Round) -> Result<Ordering, ParseFloatError>;
    assign_str_radix_round(&mut self, &str, i32, Round) -> Result<Ordering, ParseFloatError>;
    valid_str_radix(&str, i32) -> Result<(), ParseFloatError>;

impl From<(T, i32)> for Float where Float: From<(T, u32)>;
impl FromRound<T, i32> for Float where Float: FromRound<T, u32, Round = Round, Ordering = Ordering>;

from_borrow!
    impl From<(&T, u32)> for Float;
    impl FromRound<&T, u32> for Float;
Integer, Rational, Float;

from!
    impl From<(T, u32)> for Float;
    impl FromRound<T, u32> for Float;
Constant, Special, Integer, Rational, Float, u32, i32, f64, f32;

impl Assign<Constant> for Float;
impl AssignRound<Constant> for Float;
impl Assign<Special> for Float;
impl AssignRound<Special> for Float;

assign!
    impl Assign<&T> for Float;
    impl AssignRound<&T> for Float;
    impl Assign<T> for Float;
    impl AssignRound<T> for Float;
Float, Integer, Rational;

arith_binary!
    impl Imp<&T> for Float;
    impl ImpRound<&T> for Float;
    impl Imp<T> for Float;
    impl ImpRound<T> for Float;
    impl Imp<&T> for &Float; // Output = Inter
    impl ImpAssign<&T> for Float
    impl ImpAssign<T> for Float;
    struct Inter;
    impl Assign<Inter> for Float;
    impl AssignRound<Inter> for Float;
    impl From<(Inter, u32)> for Float;
    impl FromRound<Inter, u32> for Float;

arith_commut_float!
    arith_binary!<Float>
    impl Imp<Float> for &Float;
    impl ImpRound<Float> for &Float
Add, Mul;

arith_noncommut_float!
    arith_binary!<Float>
    impl Imp<Float> for &Float;
    impl ImpRound<Float> for &Float;
    impl ImpFromAssign<&Float> for Float;
    impl ImpFromAssign for Float;
Sub, Div;

arith_commut!
    arith_binary!
    impl Imp<T> for &Float; // Output = Inter
    impl Imp<Float> for &T;
    impl ImpRound<Float> for &T
    impl Imp<Float> for T;
    impl ImpRound<Float> for T;
    impl Imp<&Float> for &T; // Output = Inter
    impl Imp<&Float> for T; // Output = Inter
Add<Integer>, Mul<Integer>, Add<Rational>, Mul<Rational>;

arith_non_commut!
    arith_binary!
    impl Imp<T> for &Float; // Output = Inter
    impl Imp<Float> for &T;
    impl ImpRound<Float> for &T;
    impl Imp<Float> for T;
    impl ImpRound<Float> for T;
    impl Imp<&Float> for &T; // Output = InterFrom
    impl Imp<&Float> for T; // Output = InterFrom
    impl ImpFromAssign<&T> for Float;
    impl ImpFromAssign<T> for Float;
    struct InterFrom;
    impl Assign<InterFrom> for Float;
    impl AssignRound<InterFrom> for Float;
    impl From<(InterFrom, u32)> for Float;
    impl FromRound<InterFrom, u32> for Float;
Sub<Integer>, Div<Integer>, Sub<Rational>, Div<Rational>;
