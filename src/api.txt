trait Assign<Rhs = Self>
    assign(&mut self, Rhs);

trait NegAssign
    neg_assign(&mut self);

trait NotAssign
    not_assign(&mut self);

trait SubFromAssign<Lhs = Self>
    sub_from_assign(&mut self, Lhs);

trait DivFromAssign<Lhs = Self>
    div_from_assign(&mut self, Lhs);

trait RemFromAssign<Lhs = Self>
    rem_from_assign(&mut self, Lhs);

trait Pow<Rhs>
    type Output;
    pow(self, Rhs) -> Output;

trait PowAssign<Rhs>
    pow_assign(&mut self, Rhs);




struct Integer;
impl Drop for Integer;
impl Default for Integer;
impl Clone for Integer;

impl Integer
    new() -> Integer;
    to_u32(&self) -> Option<u32>;
    to_u32_wrapping(&self) -> u32;
    to_i32(&self) -> Option<i32>;
    to_i32_wrapping(&self) -> i32;
    assign_f64(&mut self, f64) -> Result<(), ()>;
    from_f64(f64) -> Option<Integer>;
    to_f64(&self) -> f64;
    assign_f32(&mut self, f32) -> Result<(), ()>;
    from_f32(f32) -> Option<f32>;
    to_f32(&self) -> f32;
    div_rem(&mut self, &mut Integer);
    set_div_rem(&mut self, &mut Integer, &Integer, &Integer);
    abs(&mut self) -> &mut Integer;
    set_abs(&mut self, &Integer) -> &mut Integer;
    div_exact(&mut self, &Integer) -> &mut Integer;
    set_div_exact(&mut self, &Integer, &Integer) -> &mut Integer;
    is_divisible(&self, &Integer) -> bool;
    is_divisible_u(&self, u32) -> bool;
    is_congruent(&self, &Integer, &Integer) -> bool;
    is_congruent_u(&self, u32, u32) -> bool;
    root(&mut self, u32) -> &mut Integer;
    set_root(&mut self, &Integer, u32) -> &mut Integer;
    root_rem(&mut self, &mut Integer, u32);
    set_root_rem(&mut self, &mut Integer, &Integer, u32);
    sqrt(&mut self) -> &mut Integer;
    set_sqrt(&mut self, &Integer) -> &mut Integer;
    sqrt_rem(&mut self, &mut Integer) -> &mut Integer;
    set_sqrt_rem(&mut self, &mut Integer, &Integer);
    is_perfect_power(&self) -> bool;
    is_perfect_square(&self) -> bool;
    gcd(&mut self, &Integer) -> &mut Integer;
    set_gcd(&mut self, &Integer, &Integer) -> &mut Integer;
    lcm(&mut self, &Integer) -> &mut Integer;
    set_lcm(&mut self, &Integer, &Integer) -> &mut Integer;
    invert(&mut self, &Integer) -> Option<&mut Integer>;
    set_inverse(&mut self, &Integer, &Integer) -> Option<&mut Integer>;
    set_factorial(&mut self, u32) -> &mut Integer;
    set_factorial_2(&mut self, u32) -> &mut Integer;
    set_factorial_m(&mut self, u32, u32) -> &mut Integer;
    set_primorial(&mut self, u32) -> &mut Integer;
    binomial(&mut self, u32) -> &mut Integer;
    set_binomial(&mut self, &Integer, u32) -> &mut Integer;
    set_binomial_u(&mut self, u32, u32) -> &mut Integer;
    cmp_abs(&self, &Integer) -> Ordering;
    sign(&self) -> Ordering;
    significant_bits(&self) -> u32;
    count_ones(&self) -> Option<u32>;
    ham_dist(&self, &Integer) -> Option<u32>;
    find_zero(&self, u32) -> Option<u32>;
    find_one(&self, u32) -> Option<u32>;
    set_bit(&mut self, u32, bool) -> &mut Integer;
    get_bit(&self, u32) -> bool;
    invert_bit(&mut self, u32) -> &mut Integer;
    assign_random_bits(&mut self, u32, &mut R: Rng);
    random_below(&mut self, &mut R: Rng) -> &mut Integer;
    to_string_radix(&self, i32) -> String;
    from_str_radix(&str, i32) -> Result<Integer, ParseIntegerError>;
    assign_str(&mut self, &str) -> Result<(), ParseIntegerError>;
    assign_str_radix(&mut self, &str, i32) -> Result<(), ParseIntegerError>;
    valid_str_radix(&str, i32) -> Result<(), ParseIntegerError>;

impl FromStr for Integer;

impl Assign for Integer;
impl Assign<&Integer> for Integer;
impl From<&Integer> for Integer;
impl Assign<u32> for Integer;
impl From<u32> for Integer;
impl Assign<i32> for Integer;
impl From<i32> for Integer;

arith_unary!
    impl Imp for Integer;
    impl ImpAssign for Integer;
    impl Imp for &Integer; // Output = Inter
    struct Inter derive(Clone, Copy);
    impl Assign<Inter> for Integer;
    impl From<Inter> for Integer;
Neg, Not

arith_binary!
    impl Imp<&Integer> for Integer;
    impl Imp<Integer> for Integer;
    impl ImpAssign<&Integer> for Integer;
    impl ImpAssign<Integer> for Integer;
    impl Imp<&Integer> for &Integer; // Output = Inter
    struct Inter derive(Clone, Copy);
    impl Assign<Inter> for Integer;
    impl From<Inter> for Integer;
Add, Mul, BitAnd, BitOr, BitXor

arith_noncommut!
    arith_binary!
    impl ImpFromAssign<&Integer> for Integer;
    impl ImpFromAssign<Integer> for Integer
Sub, Div, Rem

arith_prim!
    impl Imp<T> for Integer;
    impl ImpAssign<T> for Integer;
    impl Imp<T> for &Integer; // Output = Inter
    struct Inter derive(Clone, Copy);
    impl Assign<Inter> for Integer;
    impl From<Inter> for Integer;
Shl<u32>, Shr<u32>, Pow<u32>
Shl<i32>, Shr<i32>

arith_prim_non_commut!
    arith_prim!
    impl Imp<Integer> for T;
    impl ImpFromAssign<T> for Integer;
    impl Imp<&Integer> for T; // Output = InterFrom
    struct InterFrom derive(Clone, Copy);
    impl Assign<InterFrom> for Integer;
    impl From<InterFrom> for Integer;
Sub<u32>, Div<u32>, Rem<u32>
Sub<i32>, Div<i32>, Rem<i32>

arith_prim_commut!
    arith_prim!
    impl Imp<Integer> for T;
    impl Imp<&Integer> for T; // Output = Inter
Add<u32>, Mul<u32>, BitAnd<u32>, BitOr<u32>, BitXor<u32>
Add<i32>, Mul<i32>, BitAnd<i32>, BitOr<i32>, BitXor<i32>

impl Eq for Integer;
impl Ord for Integer;
impl PartialEq for Integer;
impl PartialOrd for Integer;
impl PartialOrd<f64> for Integer;
impl PartialEq<f64> for Integer;
impl PartialOrd<Integer> for f64;
impl PartialEq<Integer> for f64;
impl PartialOrd<f32> for Integer;
impl PartialEq<f32> for Integer;
impl PartialOrd<Integer> for f32;
impl PartialEq<Integer> for f32;

cmp_int!
    impl PartialOrd<T> for Integer;
    impl PartialEq<T> for Integer;
    impl PartialOrd<Integer> for T;
    impl PartialEq<Integer> for T;
u32, i32

impl Display for Integer;
impl Debug for Integer;
impl Binary for Integer;
impl Octal for Integer;
impl LowerHex for Integer;
impl UpperHex for Integer;

struct ParseIntegerError derive(Clone, Debug, Eq, PartialEq);
impl Error for ParseIntegerError;
impl Display for Parse IntegerError;
